<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Marble Madness Mobile</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Arial Rounded MT Bold', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 20px;
        }

        #timer {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 20px;
        }

        #swipeIndicator {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.4);
            padding: 8px 16px;
            border-radius: 15px;
            display: none;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 30px;
            border-radius: 20px;
            pointer-events: auto;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        #instructions h1 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #FFD700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        }

        #instructions p {
            font-size: 18px;
            margin-bottom: 20px;
        }

        #startButton {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            border-radius: 30px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }

        #startButton:active {
            transform: scale(0.95);
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 20px;
            display: none;
            pointer-events: auto;
        }

        #gameOver h2 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #FFD700;
        }

        #restartButton {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            border-radius: 30px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            margin-top: 20px;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div id="score">Score: 0</div>
        <div id="timer">Time: 0:00</div>
        <div id="swipeIndicator">Swipe Power: 0%</div>
    </div>

    <div id="instructions">
        <h1>ðŸŽ® Marble Madness ðŸŽ®</h1>
        <p>Swipe to move the marble!</p>
        <p>Collect gems ðŸ’Ž and reach the goal ðŸŽ¯</p>
        <p>Don't fall off the edge!</p>
        <button id="startButton">START GAME</button>
    </div>

    <div id="gameOver">
        <h2>ðŸŽ‰ Game Over! ðŸŽ‰</h2>
        <p id="finalScore"></p>
        <p id="finalTime"></p>
        <button id="restartButton">Play Again</button>
    </div>

    <script>
        // WebGL 2.0 Marble Madness Game
        const canvas = document.getElementById('gameCanvas');
        const gl = canvas.getContext('webgl2', { antialias: true, alpha: false });

        if (!gl) {
            alert('WebGL 2.0 is not supported on your device');
            throw new Error('WebGL 2.0 not supported');
        }

        // Resize canvas to fill screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let gameState = 'menu'; // 'menu', 'playing', 'gameover'
        let score = 0;
        let startTime = 0;
        let elapsedTime = 0;

        // Matrix utilities
        const mat4 = {
            create() {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            },

            perspective(fov, aspect, near, far) {
                const f = 1.0 / Math.tan(fov / 2);
                const nf = 1 / (near - far);
                return new Float32Array([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (far + near) * nf, -1,
                    0, 0, 2 * far * near * nf, 0
                ]);
            },

            lookAt(eye, center, up) {
                const z = [
                    eye[0] - center[0],
                    eye[1] - center[1],
                    eye[2] - center[2]
                ];
                const len = Math.sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);
                z[0] /= len; z[1] /= len; z[2] /= len;

                const x = [
                    up[1] * z[2] - up[2] * z[1],
                    up[2] * z[0] - up[0] * z[2],
                    up[0] * z[1] - up[1] * z[0]
                ];
                const xlen = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
                x[0] /= xlen; x[1] /= xlen; x[2] /= xlen;

                const y = [
                    z[1] * x[2] - z[2] * x[1],
                    z[2] * x[0] - z[0] * x[2],
                    z[0] * x[1] - z[1] * x[0]
                ];

                return new Float32Array([
                    x[0], y[0], z[0], 0,
                    x[1], y[1], z[1], 0,
                    x[2], y[2], z[2], 0,
                    -(x[0] * eye[0] + x[1] * eye[1] + x[2] * eye[2]),
                    -(y[0] * eye[0] + y[1] * eye[1] + y[2] * eye[2]),
                    -(z[0] * eye[0] + z[1] * eye[1] + z[2] * eye[2]),
                    1
                ]);
            },

            translate(m, v) {
                const out = new Float32Array(m);
                out[12] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12];
                out[13] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13];
                out[14] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14];
                return out;
            },

            scale(m, v) {
                const out = new Float32Array(16);
                out[0] = m[0] * v[0];
                out[1] = m[1] * v[0];
                out[2] = m[2] * v[0];
                out[3] = m[3] * v[0];
                out[4] = m[4] * v[1];
                out[5] = m[5] * v[1];
                out[6] = m[6] * v[1];
                out[7] = m[7] * v[1];
                out[8] = m[8] * v[2];
                out[9] = m[9] * v[2];
                out[10] = m[10] * v[2];
                out[11] = m[11] * v[2];
                out[12] = m[12];
                out[13] = m[13];
                out[14] = m[14];
                out[15] = m[15];
                return out;
            },

            multiply(a, b) {
                const out = new Float32Array(16);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        out[i * 4 + j] =
                            a[i * 4 + 0] * b[0 * 4 + j] +
                            a[i * 4 + 1] * b[1 * 4 + j] +
                            a[i * 4 + 2] * b[2 * 4 + j] +
                            a[i * 4 + 3] * b[3 * 4 + j];
                    }
                }
                return out;
            }
        };

        // Shader sources
        const vertexShaderSource = `#version 300 es
            precision highp float;

            in vec3 aPosition;
            in vec3 aNormal;
            in vec3 aColor;

            uniform mat4 uModelMatrix;
            uniform mat4 uViewMatrix;
            uniform mat4 uProjectionMatrix;

            out vec3 vNormal;
            out vec3 vColor;
            out vec3 vPosition;

            void main() {
                vec4 worldPosition = uModelMatrix * vec4(aPosition, 1.0);
                vPosition = worldPosition.xyz;
                vNormal = mat3(uModelMatrix) * aNormal;
                vColor = aColor;
                gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;
            }
        `;

        const fragmentShaderSource = `#version 300 es
            precision highp float;

            in vec3 vNormal;
            in vec3 vColor;
            in vec3 vPosition;

            out vec4 fragColor;

            uniform vec3 uLightPos;
            uniform float uTime;
            uniform float uAlpha;

            void main() {
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightPos - vPosition);

                float diffuse = max(dot(normal, lightDir), 0.0);
                float ambient = 0.3;

                // Add some shimmer
                float shimmer = sin(uTime * 3.0 + vPosition.x * 2.0 + vPosition.z * 2.0) * 0.1 + 0.9;

                vec3 color = vColor * (ambient + diffuse * 0.7) * shimmer;
                fragColor = vec4(color, uAlpha);
            }
        `;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(program));
        }

        // Get attribute and uniform locations
        const aPosition = gl.getAttribLocation(program, 'aPosition');
        const aNormal = gl.getAttribLocation(program, 'aNormal');
        const aColor = gl.getAttribLocation(program, 'aColor');
        const uModelMatrix = gl.getUniformLocation(program, 'uModelMatrix');
        const uViewMatrix = gl.getUniformLocation(program, 'uViewMatrix');
        const uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
        const uLightPos = gl.getUniformLocation(program, 'uLightPos');
        const uTime = gl.getUniformLocation(program, 'uTime');
        const uAlpha = gl.getUniformLocation(program, 'uAlpha');

        // Create sphere geometry
        function createSphere(radius, segments) {
            const positions = [];
            const normals = [];
            const colors = [];
            const indices = [];

            for (let lat = 0; lat <= segments; lat++) {
                const theta = lat * Math.PI / segments;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);

                for (let lon = 0; lon <= segments; lon++) {
                    const phi = lon * 2 * Math.PI / segments;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);

                    const x = cosPhi * sinTheta;
                    const y = cosTheta;
                    const z = sinPhi * sinTheta;

                    positions.push(radius * x, radius * y, radius * z);
                    normals.push(x, y, z);

                    // Rainbow marble colors
                    const hue = (lon / segments + lat / segments) * 0.5;
                    const r = Math.abs(Math.sin(hue * Math.PI * 2));
                    const g = Math.abs(Math.sin((hue + 0.33) * Math.PI * 2));
                    const b = Math.abs(Math.sin((hue + 0.66) * Math.PI * 2));
                    colors.push(r * 0.8 + 0.2, g * 0.8 + 0.2, b * 0.8 + 0.2);
                }
            }

            for (let lat = 0; lat < segments; lat++) {
                for (let lon = 0; lon < segments; lon++) {
                    const first = lat * (segments + 1) + lon;
                    const second = first + segments + 1;

                    indices.push(first, second, first + 1);
                    indices.push(second, second + 1, first + 1);
                }
            }

            return {
                positions: new Float32Array(positions),
                normals: new Float32Array(normals),
                colors: new Float32Array(colors),
                indices: new Uint16Array(indices)
            };
        }

        // Create box geometry
        function createBox(width, height, depth, color) {
            const w = width / 2, h = height / 2, d = depth / 2;
            const positions = new Float32Array([
                -w, -h, -d,  w, -h, -d,  w,  h, -d, -w,  h, -d, // front
                -w, -h,  d,  w, -h,  d,  w,  h,  d, -w,  h,  d, // back
                -w, -h, -d, -w, -h,  d, -w,  h,  d, -w,  h, -d, // left
                 w, -h, -d,  w, -h,  d,  w,  h,  d,  w,  h, -d, // right
                -w,  h, -d,  w,  h, -d,  w,  h,  d, -w,  h,  d, // top
                -w, -h, -d,  w, -h, -d,  w, -h,  d, -w, -h,  d  // bottom
            ]);

            const normals = new Float32Array([
                0, 0, -1,  0, 0, -1,  0, 0, -1,  0, 0, -1,
                0, 0,  1,  0, 0,  1,  0, 0,  1,  0, 0,  1,
               -1, 0,  0, -1, 0,  0, -1, 0,  0, -1, 0,  0,
                1, 0,  0,  1, 0,  0,  1, 0,  0,  1, 0,  0,
                0, 1,  0,  0, 1,  0,  0, 1,  0,  0, 1,  0,
                0, -1, 0,  0, -1, 0,  0, -1, 0,  0, -1, 0
            ]);

            const colors = [];
            for (let i = 0; i < 24; i++) {
                colors.push(...color);
            }

            const indices = new Uint16Array([
                0, 1, 2, 0, 2, 3,
                4, 5, 6, 4, 6, 7,
                8, 9, 10, 8, 10, 11,
                12, 13, 14, 12, 14, 15,
                16, 17, 18, 16, 18, 19,
                20, 21, 22, 20, 22, 23
            ]);

            return {
                positions,
                normals,
                colors: new Float32Array(colors),
                indices
            };
        }

        // Create cone geometry (for arrows)
        function createCone(radius, height, segments, color) {
            const positions = [];
            const normals = [];
            const colors = [];
            const indices = [];

            // Tip of cone
            positions.push(0, height, 0);
            normals.push(0, 1, 0);
            colors.push(...color);

            // Base circle
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                positions.push(x, 0, z);
                normals.push(x, 0.5, z);
                colors.push(...color);

                if (i < segments) {
                    indices.push(0, i + 1, i + 2);
                }
            }

            // Base cap
            const baseCenter = positions.length / 3;
            positions.push(0, 0, 0);
            normals.push(0, -1, 0);
            colors.push(...color);

            for (let i = 1; i <= segments; i++) {
                indices.push(baseCenter, i + 1, i);
            }

            return {
                positions: new Float32Array(positions),
                normals: new Float32Array(normals),
                colors: new Float32Array(colors),
                indices: new Uint16Array(indices)
            };
        }

        // Create cylinder (for walls/edges)
        function createCylinder(radius, height, segments, color) {
            const positions = [];
            const normals = [];
            const colors = [];
            const indices = [];

            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                // Bottom vertex
                positions.push(x, 0, z);
                normals.push(x, 0, z);
                colors.push(...color);

                // Top vertex
                positions.push(x, height, z);
                normals.push(x, 0, z);
                colors.push(...color);

                if (i < segments) {
                    const base = i * 2;
                    indices.push(base, base + 2, base + 1);
                    indices.push(base + 1, base + 2, base + 3);
                }
            }

            return {
                positions: new Float32Array(positions),
                normals: new Float32Array(normals),
                colors: new Float32Array(colors),
                indices: new Uint16Array(indices)
            };
        }

        // Create circle (for shadow)
        function createCircle(radius, segments, color) {
            const positions = [];
            const normals = [];
            const colors = [];
            const indices = [];

            // Center
            positions.push(0, 0, 0);
            normals.push(0, 1, 0);
            colors.push(...color);

            // Circle vertices
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                positions.push(x, 0, z);
                normals.push(0, 1, 0);
                colors.push(...color);

                if (i < segments) {
                    indices.push(0, i + 1, i + 2);
                }
            }

            return {
                positions: new Float32Array(positions),
                normals: new Float32Array(normals),
                colors: new Float32Array(colors),
                indices: new Uint16Array(indices)
            };
        }

        // Create marble
        const marbleGeometry = createSphere(0.3, 20);
        const marbleVAO = gl.createVertexArray();
        gl.bindVertexArray(marbleVAO);

        const marblePosBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, marblePosBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, marbleGeometry.positions, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(aPosition);
        gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

        const marbleNormBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, marbleNormBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, marbleGeometry.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(aNormal);
        gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

        const marbleColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, marbleColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, marbleGeometry.colors, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(aColor);
        gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

        const marbleIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, marbleIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, marbleGeometry.indices, gl.STATIC_DRAW);

        // Create shadow
        const shadowGeometry = createCircle(0.4, 20, [0, 0, 0]);
        const shadowVAO = gl.createVertexArray();
        gl.bindVertexArray(shadowVAO);

        const shadowPosBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, shadowPosBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, shadowGeometry.positions, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(aPosition);
        gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

        const shadowNormBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, shadowNormBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, shadowGeometry.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(aNormal);
        gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

        const shadowColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, shadowColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, shadowGeometry.colors, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(aColor);
        gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

        const shadowIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shadowIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shadowGeometry.indices, gl.STATIC_DRAW);

        // Create direction arrow
        const arrowGeometry = createCone(0.15, 0.6, 12, [1, 1, 0]);
        const arrowVAO = gl.createVertexArray();
        gl.bindVertexArray(arrowVAO);

        const arrowPosBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, arrowPosBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, arrowGeometry.positions, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(aPosition);
        gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

        const arrowNormBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, arrowNormBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, arrowGeometry.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(aNormal);
        gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

        const arrowColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, arrowColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, arrowGeometry.colors, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(aColor);
        gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

        const arrowIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, arrowIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrowGeometry.indices, gl.STATIC_DRAW);

        // Create wall/edge cylinder
        const wallGeometry = createCylinder(0.05, 0.5, 8, [1, 1, 1]);
        const wallVAO = gl.createVertexArray();
        gl.bindVertexArray(wallVAO);

        const wallPosBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, wallPosBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, wallGeometry.positions, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(aPosition);
        gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

        const wallNormBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, wallNormBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, wallGeometry.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(aNormal);
        gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

        const wallColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, wallColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, wallGeometry.colors, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(aColor);
        gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

        const wallIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, wallIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, wallGeometry.indices, gl.STATIC_DRAW);

        // Create level platforms
        const platforms = [];
        const gems = [];
        const obstacles = [];
        const directionArrows = [];
        const platformWalls = [];

        // Main platform path
        const platformColors = [
            [0.3, 0.8, 0.3], // Green
            [0.3, 0.3, 0.9], // Blue
            [0.9, 0.3, 0.9], // Purple
            [0.9, 0.7, 0.2], // Yellow
            [0.9, 0.4, 0.3]  // Red
        ];

        // Create winding path
        for (let i = 0; i < 15; i++) {
            const x = Math.sin(i * 0.5) * 3;
            const z = -i * 2;
            const color = platformColors[i % platformColors.length];
            platforms.push({
                geometry: createBox(3, 0.3, 2, color),
                position: [x, -1, z],
                index: i
            });

            // Add direction arrows (point to next platform)
            if (i < 14) {
                const nextX = Math.sin((i + 1) * 0.5) * 3;
                const nextZ = -(i + 1) * 2;
                const dx = nextX - x;
                const dz = nextZ - z;
                const angle = Math.atan2(dx, dz);

                directionArrows.push({
                    position: [x, -0.5, z],
                    rotation: angle
                });
            }

            // Add platform edge walls
            const edgeColor = [0.9, 0.9, 0.9];
            // Front and back walls
            platformWalls.push(
                { position: [x - 1.4, -0.85, z], rotation: 0 },
                { position: [x + 1.4, -0.85, z], rotation: 0 },
                { position: [x, -0.85, z - 0.9], rotation: Math.PI / 2 },
                { position: [x, -0.85, z + 0.9], rotation: Math.PI / 2 }
            );

            // Add gems
            if (i > 0 && i % 3 === 0) {
                gems.push({
                    geometry: createBox(0.3, 0.3, 0.3, [1, 0.84, 0]),
                    position: [x + Math.random() - 0.5, 0, z],
                    collected: false,
                    rotation: 0
                });
            }

            // Add obstacles
            if (i > 2 && i % 4 === 0) {
                obstacles.push({
                    geometry: createBox(0.5, 1, 0.5, [0.7, 0.1, 0.1]),
                    position: [x + (Math.random() - 0.5) * 1.5, -0.3, z],
                    rotation: 0
                });
            }
        }

        // Goal platform
        platforms.push({
            geometry: createBox(4, 0.3, 4, [1, 0.84, 0]),
            position: [0, -1, -30]
        });

        // Create VAOs for all platforms
        platforms.forEach(platform => {
            platform.vao = gl.createVertexArray();
            gl.bindVertexArray(platform.vao);

            const posBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, platform.geometry.positions, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

            const normBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, platform.geometry.normals, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(aNormal);
            gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, platform.geometry.colors, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(aColor);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, platform.geometry.indices, gl.STATIC_DRAW);
        });

        // Create VAOs for gems
        gems.forEach(gem => {
            gem.vao = gl.createVertexArray();
            gl.bindVertexArray(gem.vao);

            const posBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, gem.geometry.positions, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

            const normBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, gem.geometry.normals, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(aNormal);
            gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, gem.geometry.colors, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(aColor);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gem.geometry.indices, gl.STATIC_DRAW);
        });

        // Create VAOs for obstacles
        obstacles.forEach(obstacle => {
            obstacle.vao = gl.createVertexArray();
            gl.bindVertexArray(obstacle.vao);

            const posBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, obstacle.geometry.positions, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

            const normBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, obstacle.geometry.normals, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(aNormal);
            gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, obstacle.geometry.colors, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(aColor);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obstacle.geometry.indices, gl.STATIC_DRAW);
        });

        // Marble physics
        const marble = {
            position: [0, 0, 0],
            velocity: [0, 0, 0],
            radius: 0.3
        };

        const gravity = 0.02;
        const friction = 0.95;
        const bounce = 0.5;

        // Touch controls
        let touchStart = null;
        let touchEnd = null;
        let swipePower = 0;

        const swipeIndicator = document.getElementById('swipeIndicator');

        canvas.addEventListener('touchstart', (e) => {
            if (gameState !== 'playing') return;
            e.preventDefault();
            const touch = e.touches[0];
            touchStart = { x: touch.clientX, y: touch.clientY, time: Date.now() };
            swipeIndicator.style.display = 'block';
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (gameState !== 'playing') return;
            e.preventDefault();
            if (touchStart) {
                const touch = e.touches[0];
                touchEnd = { x: touch.clientX, y: touch.clientY };

                // Show swipe power
                const dx = touchEnd.x - touchStart.x;
                const dy = touchEnd.y - touchStart.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                swipePower = Math.min(100, (distance / 200) * 100);
                swipeIndicator.textContent = `Swipe Power: ${Math.floor(swipePower)}%`;
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (gameState !== 'playing') return;
            e.preventDefault();
            swipeIndicator.style.display = 'none';

            if (touchStart && touchEnd) {
                const dx = touchEnd.x - touchStart.x;
                const dy = touchEnd.y - touchStart.y;
                const timeDelta = Date.now() - touchStart.time;

                // Convert swipe to velocity
                const speed = Math.sqrt(dx * dx + dy * dy) / timeDelta;
                const angle = Math.atan2(dy, dx);

                marble.velocity[0] += Math.cos(angle) * speed * 0.3;
                marble.velocity[2] += Math.sin(angle) * speed * 0.3;

                // Limit max speed
                const maxSpeed = 0.5;
                const currentSpeed = Math.sqrt(
                    marble.velocity[0] * marble.velocity[0] +
                    marble.velocity[2] * marble.velocity[2]
                );
                if (currentSpeed > maxSpeed) {
                    marble.velocity[0] = (marble.velocity[0] / currentSpeed) * maxSpeed;
                    marble.velocity[2] = (marble.velocity[2] / currentSpeed) * maxSpeed;
                }
            }
            touchStart = null;
            touchEnd = null;
            swipePower = 0;
        }, { passive: false });

        // Update physics
        function updatePhysics() {
            // Apply gravity
            marble.velocity[1] -= gravity;

            // Apply velocity
            marble.position[0] += marble.velocity[0];
            marble.position[1] += marble.velocity[1];
            marble.position[2] += marble.velocity[2];

            // Check platform collisions
            let onPlatform = false;
            platforms.forEach(platform => {
                const px = platform.position[0];
                const py = platform.position[1];
                const pz = platform.position[2];

                // Simple AABB collision
                if (marble.position[0] > px - 1.5 && marble.position[0] < px + 1.5 &&
                    marble.position[2] > pz - 1 && marble.position[2] < pz + 1) {

                    if (marble.position[1] - marble.radius < py + 0.15 &&
                        marble.position[1] > py) {
                        marble.position[1] = py + 0.15 + marble.radius;
                        marble.velocity[1] = 0;
                        marble.velocity[0] *= friction;
                        marble.velocity[2] *= friction;
                        onPlatform = true;
                    }
                }
            });

            // Check gem collection
            gems.forEach(gem => {
                if (gem.collected) return;

                const dx = marble.position[0] - gem.position[0];
                const dy = marble.position[1] - gem.position[1];
                const dz = marble.position[2] - gem.position[2];
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (dist < 0.5) {
                    gem.collected = true;
                    score += 100;
                    updateScore();
                }
            });

            // Check obstacle collisions
            obstacles.forEach(obstacle => {
                const dx = marble.position[0] - obstacle.position[0];
                const dy = marble.position[1] - obstacle.position[1];
                const dz = marble.position[2] - obstacle.position[2];
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < 0.7 && Math.abs(dy) < 0.8) {
                    // Bounce back
                    const angle = Math.atan2(dz, dx);
                    marble.velocity[0] = Math.cos(angle) * 0.3;
                    marble.velocity[2] = Math.sin(angle) * 0.3;
                }
            });

            // Check win condition
            if (marble.position[2] < -28 &&
                marble.position[0] > -2 && marble.position[0] < 2) {
                if (onPlatform) {
                    endGame(true);
                }
            }

            // Check fall off
            if (marble.position[1] < -5) {
                endGame(false);
            }
        }

        // Render
        function render(time) {
            time *= 0.001; // Convert to seconds

            if (gameState === 'playing') {
                updatePhysics();
                elapsedTime = time - startTime;
                updateTimer();
            }

            // Clear
            gl.clearColor(0.2, 0.3, 0.5, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);

            // Use program
            gl.useProgram(program);

            // Set up camera
            const aspect = canvas.width / canvas.height;
            const projectionMatrix = mat4.perspective(Math.PI / 4, aspect, 0.1, 100);

            const cameraPos = [
                marble.position[0] + 5,
                marble.position[1] + 6,
                marble.position[2] + 8
            ];
            const viewMatrix = mat4.lookAt(
                cameraPos,
                marble.position,
                [0, 1, 0]
            );

            gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
            gl.uniformMatrix4fv(uViewMatrix, false, viewMatrix);
            gl.uniform3fv(uLightPos, [10, 10, 10]);
            gl.uniform1f(uTime, time);
            gl.uniform1f(uAlpha, 1.0);

            // Find current platform for marble
            let currentPlatformIndex = 0;
            platforms.forEach((platform, idx) => {
                const px = platform.position[0];
                const pz = platform.position[2];
                const dist = Math.sqrt(
                    (marble.position[0] - px) * (marble.position[0] - px) +
                    (marble.position[2] - pz) * (marble.position[2] - pz)
                );
                if (dist < 3) {
                    currentPlatformIndex = idx;
                }
            });

            // Render marble shadow (with transparency)
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            let shadowY = -0.85; // Default shadow height
            // Find platform height under marble
            platforms.forEach(platform => {
                const px = platform.position[0];
                const pz = platform.position[2];
                if (marble.position[0] > px - 1.5 && marble.position[0] < px + 1.5 &&
                    marble.position[2] > pz - 1 && marble.position[2] < pz + 1) {
                    shadowY = platform.position[1] + 0.16;
                }
            });

            let modelMatrix = mat4.create();
            modelMatrix = mat4.translate(modelMatrix, [marble.position[0], shadowY, marble.position[2]]);
            const shadowScale = Math.max(0.3, 1.0 - (marble.position[1] - shadowY) * 0.1);
            modelMatrix = mat4.scale(modelMatrix, [shadowScale, 1, shadowScale]);

            const shadowAlpha = Math.max(0.1, 0.5 - (marble.position[1] - shadowY) * 0.05);
            gl.uniform1f(uAlpha, shadowAlpha);
            gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix);
            gl.bindVertexArray(shadowVAO);
            gl.drawElements(gl.TRIANGLES, shadowGeometry.indices.length, gl.UNSIGNED_SHORT, 0);

            gl.disable(gl.BLEND);
            gl.uniform1f(uAlpha, 1.0);

            // Render marble
            modelMatrix = mat4.create();
            modelMatrix = mat4.translate(modelMatrix, marble.position);
            gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix);
            gl.bindVertexArray(marbleVAO);
            gl.drawElements(gl.TRIANGLES, marbleGeometry.indices.length, gl.UNSIGNED_SHORT, 0);

            // Render platforms
            platforms.forEach((platform, idx) => {
                modelMatrix = mat4.create();
                modelMatrix = mat4.translate(modelMatrix, platform.position);

                // Highlight next platform
                if (idx === currentPlatformIndex + 1 && idx < platforms.length - 1) {
                    const pulseScale = 1.0 + Math.sin(time * 4) * 0.05;
                    modelMatrix = mat4.scale(modelMatrix, [pulseScale, 1, pulseScale]);
                }

                gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix);
                gl.bindVertexArray(platform.vao);
                gl.drawElements(gl.TRIANGLES, platform.geometry.indices.length, gl.UNSIGNED_SHORT, 0);
            });

            // Render platform edge walls
            platformWalls.forEach(wall => {
                modelMatrix = mat4.create();
                modelMatrix = mat4.translate(modelMatrix, wall.position);

                // Rotate wall
                const rotY = new Float32Array([
                    Math.cos(wall.rotation), 0, Math.sin(wall.rotation), 0,
                    0, 1, 0, 0,
                    -Math.sin(wall.rotation), 0, Math.cos(wall.rotation), 0,
                    0, 0, 0, 1
                ]);
                modelMatrix = mat4.multiply(modelMatrix, rotY);

                gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix);
                gl.bindVertexArray(wallVAO);
                gl.drawElements(gl.TRIANGLES, wallGeometry.indices.length, gl.UNSIGNED_SHORT, 0);
            });

            // Render direction arrows (with animation)
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            directionArrows.forEach((arrow, idx) => {
                // Only show arrows near the marble
                const dx = arrow.position[0] - marble.position[0];
                const dz = arrow.position[2] - marble.position[2];
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < 10) {
                    modelMatrix = mat4.create();
                    modelMatrix = mat4.translate(modelMatrix, arrow.position);

                    // Rotate arrow to point to next platform
                    const rotY = new Float32Array([
                        Math.cos(arrow.rotation), 0, Math.sin(arrow.rotation), 0,
                        0, 1, 0, 0,
                        -Math.sin(arrow.rotation), 0, Math.cos(arrow.rotation), 0,
                        0, 0, 0, 1
                    ]);
                    modelMatrix = mat4.multiply(modelMatrix, rotY);

                    // Pulse animation
                    const pulse = Math.sin(time * 3 + idx * 0.5) * 0.15 + 1.0;
                    modelMatrix = mat4.scale(modelMatrix, [pulse, pulse, pulse]);

                    // Fade based on distance
                    const alpha = Math.max(0.3, 1.0 - dist / 10);
                    gl.uniform1f(uAlpha, alpha);

                    gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix);
                    gl.bindVertexArray(arrowVAO);
                    gl.drawElements(gl.TRIANGLES, arrowGeometry.indices.length, gl.UNSIGNED_SHORT, 0);
                }
            });

            gl.disable(gl.BLEND);
            gl.uniform1f(uAlpha, 1.0);

            // Render gems
            gems.forEach(gem => {
                if (gem.collected) return;

                gem.rotation += 0.03;
                modelMatrix = mat4.create();
                modelMatrix = mat4.translate(modelMatrix, gem.position);

                // Rotate gem
                const rotY = new Float32Array([
                    Math.cos(gem.rotation), 0, Math.sin(gem.rotation), 0,
                    0, 1, 0, 0,
                    -Math.sin(gem.rotation), 0, Math.cos(gem.rotation), 0,
                    0, 0, 0, 1
                ]);
                modelMatrix = mat4.multiply(modelMatrix, rotY);

                // Bob up and down
                const bobOffset = Math.sin(time * 2 + gem.position[0]) * 0.2;
                modelMatrix = mat4.translate(modelMatrix, [0, bobOffset, 0]);

                gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix);
                gl.bindVertexArray(gem.vao);
                gl.drawElements(gl.TRIANGLES, gem.geometry.indices.length, gl.UNSIGNED_SHORT, 0);
            });

            // Render obstacles
            obstacles.forEach(obstacle => {
                obstacle.rotation += 0.02;
                modelMatrix = mat4.create();
                modelMatrix = mat4.translate(modelMatrix, obstacle.position);

                const rotY = new Float32Array([
                    Math.cos(obstacle.rotation), 0, Math.sin(obstacle.rotation), 0,
                    0, 1, 0, 0,
                    -Math.sin(obstacle.rotation), 0, Math.cos(obstacle.rotation), 0,
                    0, 0, 0, 1
                ]);
                modelMatrix = mat4.multiply(modelMatrix, rotY);

                gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix);
                gl.bindVertexArray(obstacle.vao);
                gl.drawElements(gl.TRIANGLES, obstacle.geometry.indices.length, gl.UNSIGNED_SHORT, 0);
            });

            requestAnimationFrame(render);
        }

        // UI functions
        function updateScore() {
            document.getElementById('score').textContent = `Score: ${score}`;
        }

        function updateTimer() {
            const minutes = Math.floor(elapsedTime / 60);
            const seconds = Math.floor(elapsedTime % 60);
            document.getElementById('timer').textContent =
                `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function startGame() {
            gameState = 'playing';
            score = 0;
            startTime = performance.now() * 0.001;
            marble.position = [0, 0, 0];
            marble.velocity = [0, 0, 0];
            gems.forEach(gem => gem.collected = false);

            document.getElementById('instructions').classList.add('hidden');
            document.getElementById('gameOver').style.display = 'none';

            updateScore();
            updateTimer();
        }

        function endGame(won) {
            gameState = 'gameover';

            const gameOverDiv = document.getElementById('gameOver');
            const finalScoreP = document.getElementById('finalScore');
            const finalTimeP = document.getElementById('finalTime');

            if (won) {
                gameOverDiv.querySelector('h2').textContent = 'ðŸŽ‰ You Win! ðŸŽ‰';
                finalScoreP.textContent = `Final Score: ${score}`;
            } else {
                gameOverDiv.querySelector('h2').textContent = 'ðŸ’¥ Try Again! ðŸ’¥';
                finalScoreP.textContent = `Score: ${score}`;
            }

            const minutes = Math.floor(elapsedTime / 60);
            const seconds = Math.floor(elapsedTime % 60);
            finalTimeP.textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;

            gameOverDiv.style.display = 'block';
        }

        // Event listeners
        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('restartButton').addEventListener('click', startGame);

        // Start rendering
        requestAnimationFrame(render);
    </script>
</body>
</html>
